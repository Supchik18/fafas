#define WIN32_LEAN_AND_MEAN

#include <iostream>
#include <Windows.h>
#include <WinSock2.h>
#include <WS2tcpip.h>
#include <Windows.h> 
#include <WinSock2.h> 
#include <WS2tcpip.h> 

using namespace std;

int main() /* Это объявление точки входа в программу. Это функция, которая будет выполняться при запуске программы.*/
{
	WSADATA wsaData;/* Это структура, которая используется для хранения информации о версии Winsock, которую использует приложение. Она необходима для инициализации Winsock.
*/
	ADDRINFO hints;/* Это структура, которая используется для настройки параметров поиска адреса при вызове функции getaddrinfo(). Она используется для задания критериев, по которым будет выполняться поиск.*/
	ADDRINFO* addrResult;/*Это указатель на структуру ADDRINFO, которая будет содержать результат поиска адреса, выполненного функцией getaddrinfo().*/
	SOCKET ClientSocket = INVALID_SOCKET;/*Это объявление переменной ClientSocket типа SOCKET, которая будет использоваться для создания сокета клиента. Изначально она инициализируется значением INVALID_SOCKET.*/
	SetConsoleCP(1251);
	setlocale(LC_ALL, "Russian");/*Перевод на русский*/


	const char* sendBuffer1 = "я РУССКИЙ";/*Первое сообщение*/
	const char* sendBuffer2 = "Я ЛЮБЛЮ РОССИЮ";/*второе сообщение*/
	char recvBuffer[512];/*Эта строка объявляет массив recvBuffer размером 512 байт, который будет использоваться для хранения данных, полученных от сервера.
*/


	int result = WSAStartup(MAKEWORD(2, 2), &wsaData); /*   - Эта строка инициализирует использование Winsock (Windows Socket API) в программе.
   - MAKEWORD(2, 2) указывает, что программа будет использовать версию Winsock 2.2.
   - &wsaData - это адрес структуры WSADATA, которая будет заполнена информацией о текущей версии Winsock.
   - Функция WSAStartup() возвращает 0 в случае успешной инициализации, или ненулевое значение в случае ошибки.*/
	if (result != 0) {
		cout << "WSAStartup failed" << endl;
		return 1; /*- Этот блок проверяет, была ли инициализация Winsock успешной.
   - Если WSAStartup() вернула ненулевое значение, то выводится сообщение об ошибке и программа завершается с кодом ошибки 1.*/
	}
	ZeroMemory(&hints, sizeof(hints)); /*  - Эта строка заполняет структуру hints нулевыми значениями.
   - Это необходимо, чтобы обнулить все поля структуры перед их заполнением.*/
	hints.ai_family = AF_INET; /* - Эта строка устанавливает поле ai_family структуры hints в значение AF_INET, что означает использование IPv4-адресов.*/
	hints.ai_socktype = SOCK_STREAM; /*Эта строка устанавливает поле ai_socktype структуры hints в значение SOCK_STREAM, что означает использование потокового (TCP) соединения.*/
	hints.ai_protocol = IPPROTO_TCP;/*Эта строка устанавливает поле ai_protocol структуры hints в значение IPPROTO_TCP, что означает использование протокола TCP.*/

	result = getaddrinfo("localhost", "788", &hints, &addrResult);
	if (result != 0) {
		cout << "getaddrinfo failed" << endl;
		return 1;
	}/*1. getaddrinfo() ищет информацию о сетевом адресе для "localhost:788" на основе настроек в hints.
2. Результат поиска сохраняется в addrResult.
3. Если getaddrinfo() вернула ненулевое значение, значит произошла ошибка, которая выводится на консоль, и программа завершается с кодом ошибки 1.*/
	ClientSocket = socket(addrResult->ai_family, addrResult->ai_socktype, addrResult->ai_protocol);
	if (ClientSocket == INVALID_SOCKET) {
		cout << "socket creation with error" << endl;
		freeaddrinfo(addrResult);
		return 1;
	}
	result = connect(ClientSocket, addrResult->ai_addr, (int)addrResult->ai_addrlen);
	if (result == SOCKET_ERROR) {
		cout << "Unable to connect server" << endl;
		freeaddrinfo(addrResult);
		WSACleanup();
		return 1;
	}/*1. Создание сокета на основе параметров из addrResult.
2. Проверка, если сокет не создан (INVALID_SOCKET), то выводим ошибку, освобождаем addrResult и возвращаем код ошибки 1.

Таким образом, этот код пытается создать новый сокет. Если создание сокета не удалось, выводится сообщение об ошибке, освобождается память, занятая addrResult, и программа завершается с кодом ошибки 1.*/
	result = send(ClientSocket, sendBuffer1, (int)strlen(sendBuffer1), MSG_DONTROUTE);/* - Функция send() отправляет данные из sendBuffer1 с использованием сокета ClientSocket.
   - strlen(sendBuffer1) определяет длину данных для отправки.
   - MSG_DONTROUTE - флаг, указывающий, что сообщение не должно передаваться через маршрутизатор.
   - Функция send() возвращает количество фактически отправленных байт или SOCKET_ERROR в случае ошибки.*/
	if (result == SOCKET_ERROR) {
		cout << "send Failed" << endl;
		freeaddrinfo(addrResult);
		WSACleanup();
		return 1;
	}/* - Этот блок проверяет, была ли отправка данных успешной.
   - Если send() вернула SOCKET_ERROR, значит произошла ошибка при отправке.
   - В этом случае выводится сообщение об ошибке, освобождается память, занятая addrResult, вызывается WSACleanup() для очистки данных WinSock, и программа завершается с кодом ошибки 1.*/
	cout << "Sent " << result << " bytes" << endl;/*Вызывается функция send() для отправки данных из sendBuffer1 через сокет ClientSocket.
*/

	result = send(ClientSocket, sendBuffer2, (int)strlen(sendBuffer2), MSG_DONTROUTE);
	if (result == SOCKET_ERROR) {
		cout << "send Failed" << endl;
		freeaddrinfo(addrResult);
		WSACleanup();
		return 1;
	}/*пытается отправить данные из sendBuffer2 через сокет ClientSocket. Если отправка не удалась (result == SOCKET_ERROR), выводится сообщение об ошибке, освобождается память, очищается WinSock, и программа завершается с кодом ошибки 1.
*/
	cout << "Sent " << result << " bytes" << endl;

	result = shutdown(ClientSocket, SD_SEND);/*	- Вызывается функция shutdown() для отключения передачи данных через сокет ClientSocket.
   - Параметр SD_SEND означает, что отключается только отправка данных, а прием данных продолжается.
   - Функция возвращает 0 при успешном выполнении или SOCKET_ERROR в случае ошибки.*/
	if (result == SOCKET_ERROR) {
		cout << "shutdown error" << endl;
		freeaddrinfo(addrResult);
		WSACleanup();
		return 1;
	}/* - Проверяется, была ли операция shutdown() успешной.
   - Если вернулся SOCKET_ERROR, то выводится сообщение об ошибке, освобождается память, занятая addrResult, вызывается WSACleanup() для очистки данных WinSock, и программа завершается с кодом ошибки 1.*/
	

	do {
		ZeroMemory(recvBuffer, 512);
		result = recv(ClientSocket, recvBuffer, 512, 0);
		if (result > 0) {
			cout << "Получено " << result << " байт" << endl;
			cout << "Получено " << recvBuffer << endl;
		}
		else if (result == 0) {
			cout << "Connection closed" << endl;
		}
		else {
			cout << "Сообщение не получено" << endl;
		}
	} while (result > 0);/* Начинается цикл, в котором происходит прием данных от клиента.
   - Внутри цикла вызывается recv(ClientSocket, recvBuffer, 512, 0) для чтения данных из сокета ClientSocket в recvBuffer размером 512 байт.
   - Функция recv() возвращает количество фактически полученных байт, либо 0 при закрытии соединения,
*/
	closesocket(ClientSocket);/* Эта функция закрывает сокет ClientSocket, который использовался для связи с клиентом.*/
	freeaddrinfo(addrResult);/*Эта функция освобождает память, занятую структурой addrResult, которая содержала информацию об адресе сервера.*/
	WSACleanup();/*Эта функция очищает ресурсы, используемые библиотекой Winsock (Windows Sockets), которая использовалась для сетевых операций.*/
}
/*1. shotdown - частичное или полное закрытие соединения
2. accept - принятие входящего соединения со стороны клиент сокет
3. bind - привязка адреса и порта к конкретному сокету
4. listen - системный вызов, который прослушивает подключения
5. Вызвать системный вызов WSACleanup
6. Вызвать системный вызов freeaddrinfo()
7. Функция getaddrinfo разрешает адрес и заполняет структуру addrinfo, которая будет использоваться при создании сокета
8. Асинхронные операции выполняются одновременно с другими операциями. Программа не ждет выполнения операции, а переходит к другой
9. Синхронные операции выполняются последовательно, одна за другой. Это означает, что программа ожидает завершения текущей операции
10. Потому что клиент подключается к серверу и передает на него сообщения, а сервер действует только в ответ на действия клиента (принимает подключение, принимает сообщения, отправляет сообщения только в ответ)
11. Мы не используем флаги потому, что нам достаточно стандартных функций и настроек
12. SOMAXCONN - это константа, которая представляет максимально допустимое значение для данной платформы.
13. Закрытие отправления данных с сокета
14. TCP - отправка данных с подтверждением, UDP - отправка без подтверждения
15. При помощи системного вызова listen
16. Сначала инициализируем WinSock, далее задаем ему необходимые параметры(тип сокета, проток передачи, тип IP), разрешаем адрес и порт и инициализируем сокет.
17. Буфер для приема используется для временного хранения данных, что позволяет сохранять целостность данных так как данные могут приходить в любом порядке или разбиваться.
18. IP-адрес и порт идентифицируют узлы и приложения в сети. IP-адрес указывает на конкретное устройство в сети, а порт определяет конкретное приложение на этом устройстве.
19. Сокеты – это абстракция, предоставляемая операционной системой для взаимодействия с сетью.
20. Connect - это системный вызов для установления соединения с ServerSocket
21. bind
22. getaddrinfo*/
